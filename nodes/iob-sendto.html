<script type="text/javascript">
RED.nodes.registerType('iobsendto', {
    category: 'ioBroker WS',
    color: '#a6bbcf',
    defaults: {
        name: { value: "" },
        adapter: { value: "" },
        command: { value: "" },
        message: { value: "" },
        waitForResponse: { value: false },
        responseTimeout: { value: 10000 },
        server: { value: "", type: "iob-config" }
    },
    inputs: 1,
    outputs: 1,
    icon: "iobroker_sendto.svg",
    paletteLabel: "WS ioB sendTo",
    label: function() {
        if (this.name) return this.name;
        
        let label = this.adapter || "iob-sendto";
        if (this.command) {
            label += ` (${this.command})`;
        }
        return label;
    },
    
    oneditprepare: function() {
        const serverInput = $('#node-input-server');
        
        if (!this.server || this.server === '') {
            const configNodes = [];
            RED.nodes.eachConfig(function(config) {
                if (config.type === 'iob-config') {
                    configNodes.push(config);
                }
            });
            
            if (configNodes.length === 1) {
                this.server = configNodes[0].id;
                serverInput.val(this.server);
                
                setTimeout(() => {
                    RED.notify(`Automatically selected server: ${configNodes[0].name || configNodes[0].iobhost}`, {
                        type: "info",
                        timeout: 1500
                    });
                }, 500);
            }
        }
        
        $('#node-input-waitForResponse').on('change', function() {
            const isChecked = $(this).prop('checked');
            $('#response-timeout-container').toggle(isChecked);
            $('#response-info').toggle(isChecked);
            
            if (isChecked) {
                $('#no-response-info').hide();
            } else {
                $('#no-response-info').show();
            }
        });
        
        const waitForResponseChecked = $('#node-input-waitForResponse').prop('checked');
        $('#response-timeout-container').toggle(waitForResponseChecked);
        $('#response-info').toggle(waitForResponseChecked);
        $('#no-response-info').toggle(!waitForResponseChecked);
        
        // Initialize adapter suggestions - reused from history node
        initializeAdapterSuggestions();
        
        function initializeAdapterSuggestions() {
            showDefaultAdapterSuggestions();
            setTimeout(() => {
                loadAvailableAdapters();
            }, 1000);
        }
        
        function showDefaultAdapterSuggestions() {
            $('.adapter-list').html('<span style="color: #6c757d; font-style: italic;">Loading available adapters...</span>');
            $('.adapter-suggestions').show();
        }
        
        function loadAvailableAdapters() {
            const serverNode = RED.nodes.node(serverInput.val());
            if (!serverNode) {
                console.log('No server node selected for adapter discovery');
                return;
            }
            
            const serverId = `${serverNode.iobhost}:${serverNode.iobport}`;
            console.log('Loading adapters from:', serverId);
            
            // Use states API to get all adapter information
            $.ajax({
                url: `/iobroker/ws/states/${encodeURIComponent(serverId)}`,
                method: 'GET',
                timeout: 15000,
                dataType: 'json',
                cache: false
            }).done(function(response) {
                console.log('Adapter states response:', response);
                
                if (response && typeof response === 'object') {
                    const adapters = extractAdaptersFromStates(response);
                    
                    if (adapters.length > 0) {
                        // Create buttons with status indicators
                        const adapterButtons = adapters.map(adapter => {
                            const statusClass = adapter.alive ? 'alive' : (adapter.enabled ? 'enabled' : 'disabled');
                            const statusIcon = adapter.alive ? '🟢' : (adapter.enabled ? '🟡' : '🔴');
                            const title = `${adapter.name} - ${adapter.alive ? 'Running' : adapter.enabled ? 'Enabled but not running' : 'Disabled'}`;
                            
                            return `<a href="#" data-adapter="${adapter.name}" class="${statusClass}" title="${title}">${statusIcon} ${adapter.name}</a>`;
                        }).join('');
                        
                        // Add common adapters that might not be installed yet
                        const commonAdapters = ['telegram.0', 'email', 'pushover.0', 'javascript.0', 'sql.0', 'influxdb.0', 'spotify-premium.0'];
                        const fallbacks = commonAdapters.filter(name => 
                            !adapters.find(a => a.name === name)
                        ).map(name => 
                            `<a href="#" data-adapter="${name}" class="fallback" title="Common adapter (not verified)">${name}</a>`
                        ).join('');
                        
                        $('.adapter-list').html(adapterButtons + fallbacks);
                        
                        // Re-add click handlers
                        $('.adapter-list a').on('click', function(e) {
                            e.preventDefault();
                            const adapter = $(this).data('adapter');
                            $('#node-input-adapter').val(adapter);
                            $(this).addClass('selected').siblings().removeClass('selected');
                            return false;
                        });
                        
                        // Highlight current selection
                        const currentAdapter = $('#node-input-adapter').val();
                        $(`.adapter-list a[data-adapter="${currentAdapter}"]`).addClass('selected');
                        
                        $('.adapter-suggestions').show();
                        
                        console.log(`Found ${adapters.length} adapters on ${serverId}`);
                    } else {
                        showFallbackAdapters();
                    }
                } else {
                    showFallbackAdapters();
                }
            }).fail(function(xhr, status, error) {
                console.error('Failed to load adapters:', status, error);
                showFallbackAdapters();
            });
        }
        
        function extractAdaptersFromStates(states) {
            const adapterConfigs = new Map();
            
            // Extract adapter information from states
            Object.keys(states).forEach(stateId => {
                // Look for alive states of adapters
                const aliveMatch = stateId.match(/^system\.adapter\.([^.]+)\.(\d+)\.alive$/);
                if (aliveMatch) {
                    const adapterType = aliveMatch[1];
                    const instance = parseInt(aliveMatch[2]);
                    const adapterName = `${adapterType}.${instance}`;
                    
                    const state = states[stateId];
                    const isAlive = state && typeof state.val === 'boolean' ? state.val : Boolean(state?.val);
                    
                    if (!adapterConfigs.has(adapterName)) {
                        adapterConfigs.set(adapterName, {
                            name: adapterName,
                            type: adapterType,
                            instance: instance,
                            enabled: false,
                            alive: isAlive
                        });
                    } else {
                        adapterConfigs.get(adapterName).alive = isAlive;
                    }
                }
                
                // Look for enabled states of adapters
                const enabledMatch = stateId.match(/^system\.adapter\.([^.]+)\.(\d+)\.enabled$/);
                if (enabledMatch) {
                    const adapterType = enabledMatch[1];
                    const instance = parseInt(enabledMatch[2]);
                    const adapterName = `${adapterType}.${instance}`;
                    
                    const state = states[stateId];
                    const isEnabled = state && typeof state.val === 'boolean' ? state.val : Boolean(state?.val);
                    
                    if (!adapterConfigs.has(adapterName)) {
                        adapterConfigs.set(adapterName, {
                            name: adapterName,
                            type: adapterType,
                            instance: instance,
                            enabled: isEnabled,
                            alive: false
                        });
                    } else {
                        adapterConfigs.get(adapterName).enabled = isEnabled;
                    }
                }
            });

            // Convert map to array and filter relevant adapters
            const adapters = [];
            for (const config of adapterConfigs.values()) {
                // Exclude admin and system adapters from sendTo suggestions
                if (!['admin', 'discovery', 'backitup', 'objects', 'states', 'web'].includes(config.type)) {
                    adapters.push(config);
                }
            }

            // Sort by type and instance
            adapters.sort((a, b) => {
                if (a.type !== b.type) return a.type.localeCompare(b.type);
                return a.instance - b.instance;
            });

            return adapters;
        }
        
        function showFallbackAdapters() {
            console.log('No adapters found or error occurred, showing fallback options');
            
            const fallbackAdapters = ['telegram.0', 'email', 'pushover.0', 'javascript.0', 'sql.0', 'influxdb.0', 'spotify-premium.0', 'sonos.0', 'kodi.0'];
            $('.adapter-list').html(
                '<span style="color: #dc3545; margin-right: 10px;">⚠️ Could not load from server</span>' +
                fallbackAdapters.map(adapter => 
                    `<a href="#" data-adapter="${adapter}" class="fallback" title="Common adapter (not verified)">${adapter}</a>`
                ).join('')
            );
            
            // Add click handlers for fallback
            $('.adapter-list a').on('click', function(e) {
                e.preventDefault();
                const adapter = $(this).data('adapter');
                $('#node-input-adapter').val(adapter);
                $(this).addClass('selected').siblings().removeClass('selected');
                return false;
            });
        }
        
        // Reload adapters when server changes
        serverInput.on('change', function() {
            console.log('Server changed, reloading adapters...');
            $('.adapter-suggestions').hide();
            setTimeout(() => {
                showDefaultAdapterSuggestions();
                setTimeout(loadAvailableAdapters, 500);
            }, 100);
        });
    },
    
    oneditresize: function() {
    }
});
</script>

<script type="text/html" data-template-name="iobsendto">
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    
    <div class="form-row">
        <label for="node-input-adapter"><i class="icon-tag"></i> Target Adapter</label>
        <input type="text" id="node-input-adapter" placeholder="e.g. telegram.0, email, sql.0 (if empty, msg.adapter is used)">
        <div class="adapter-suggestions" style="margin-top: 5px; display: none;">
            <span style="font-size: 12px; color: #666;">Available adapters: </span>
            <span class="adapter-list" style="font-size: 12px;"></span>
        </div>
        <style>
            .adapter-suggestions {
                margin-top: 8px;
                padding: 8px;
                background-color: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                font-size: 12px;
            }
            .adapter-suggestions a {
                display: inline-block;
                margin: 2px 8px 2px 0;
                padding: 4px 8px;
                background-color: #e9ecef;
                border: 1px solid #ced4da;
                border-radius: 3px;
                text-decoration: none;
                color: #495057;
                font-size: 11px;
                cursor: pointer;
                transition: all 0.2s ease;
            }
            .adapter-suggestions a:hover {
                background-color: #007bff;
                border-color: #007bff;
                color: white;
            }
            .adapter-suggestions a.selected {
                background-color: #28a745;
                border-color: #28a745;
                color: white;
            }
            .adapter-suggestions a.alive {
                background-color: #d4edda;
                border-color: #c3e6cb;
                color: #155724;
            }
            .adapter-suggestions a.enabled {
                background-color: #fff3cd;
                border-color: #ffeaa7;
                color: #856404;
            }
            .adapter-suggestions a.disabled {
                background-color: #f8d7da;
                border-color: #f5c6cb;
                color: #721c24;
                opacity: 0.7;
            }
            .adapter-suggestions a.fallback {
                background-color: #f8f9fa;
                border-color: #dee2e6;
                color: #6c757d;
                border-style: dashed;
            }
        </style>
    </div>
    
    <div class="form-row">
        <label for="node-input-command"><i class="icon-tag"></i> Command</label>
        <input type="text" id="node-input-command" placeholder="e.g. send, query, toScript (optional, can be empty)">
    </div>
    
    <div class="form-row">
        <label for="node-input-message"><i class="icon-tag"></i> Static Message</label>
        <textarea id="node-input-message" rows="4" style="width:100%; font-family: monospace;" placeholder="Optional JSON message (leave empty to use msg.payload)"></textarea>
        <div style="margin-top: 5px; font-size: 12px; color: #666;">
            If empty, <code>msg.payload</code> will be used as the message content
        </div>
    </div>
    
    <div class="form-row">
        <label for="node-input-waitForResponse" style="width: auto;">
            <input type="checkbox" id="node-input-waitForResponse" style="width: auto; margin-right: 5px;">
            <i class="icon-tag"></i> Wait for response
        </label>
    </div>
    
    <div class="form-row" id="response-timeout-container" style="display: none;">
        <label for="node-input-responseTimeout"><i class="icon-tag"></i> Response Timeout</label>
        <input type="number" id="node-input-responseTimeout" style="width: 120px;" min="1000" max="60000" step="1000"> ms
    </div>
    
    <div id="response-info" style="display: none; margin-top: 5px; padding: 8px; background-color: #e8f4fd; border: 1px solid #bee5eb; border-radius: 4px; font-size: 12px; color: #0c5460;">
        <i class="fa fa-info-circle"></i> <strong>Response Mode:</strong><br>
        Node will wait for adapter response and send it as output message. Useful for queries and commands that return data.
    </div>
    
    <div id="no-response-info" style="margin-top: 5px; padding: 8px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; font-size: 12px; color: #856404;">
        <i class="fa fa-info-circle"></i> <strong>Fire-and-forget Mode:</strong><br>
        Node will send the command and not wait for response. No output will be generated.
    </div>
    
    <div class="form-row">
        <label for="node-input-server"><i class="icon-tag"></i> Server</label>
        <input type="text" id="node-input-server">
    </div>
</script>

<script type="text/html" data-help-name="iobsendto">
    <p>ioBroker sendTo command via WebSocket for adapter-to-adapter communication and service integration.</p>
    
    <h3>Configuration</h3>
    <ul>
        <li><b>Target Adapter:</b> The adapter instance to send command to. If empty, <code>msg.adapter</code> is used.</li>
        <li><b>Command:</b> Optional command parameter. Some adapters require this, others don't.</li>
        <li><b>Static Message:</b> Optional JSON message to send. If empty, <code>msg.payload</code> is used.</li>
        <li><b>Wait for Response:</b> Enable to receive adapter response as output message.</li>
        <li><b>Response Timeout:</b> Maximum time to wait for response (1-60 seconds).</li>
        <li><b>Server:</b> The ioBroker server configuration.</li>
    </ul>
    
    <h3>Input Message</h3>
    <p>Message properties that can override node configuration:</p>
    <ul>
        <li><code>msg.adapter</code> - Target adapter (overrides node setting)</li>
        <li><code>msg.command</code> - Command parameter (overrides node setting)</li>
        <li><code>msg.message</code> - Message content (overrides node setting and msg.payload)</li>
        <li><code>msg.payload</code> - Used as message if no static message configured</li>
        <li><code>msg.timeout</code> - Response timeout in milliseconds (overrides node setting)</li>
    </ul>
    
    <h3>Common Use Cases</h3>
    
    <h4>Telegram Notifications</h4>
    <pre>// Node config: adapter="telegram.0", command="send"
msg.payload = {
    text: "Motion detected in living room!",
    user: "admin"
}</pre>
    
    <h4>Email Alerts</h4>
    <pre>// Node config: adapter="email", command=""
msg.payload = {
    to: "admin@home.com",
    subject: "System Alert",
    text: "Temperature critical: 85°C"
}</pre>
    
    <h4>SQL Database Queries</h4>
    <pre>// Node config: adapter="sql.0", command="query", waitForResponse=true
msg.payload = "SELECT * FROM datapoints WHERE ts > NOW() - INTERVAL 1 DAY"</pre>
    
    <h4>JavaScript Execution</h4>
    <pre>// Node config: adapter="javascript.0", command="toScript"
msg.payload = {
    script: "myScript",
    message: { action: "cleanup", data: [1,2,3] }
}</pre>
    
    <h4>Media Control</h4>
    <pre>// Node config: adapter="spotify-premium.0", command="play"
msg.payload = {
    playlist: "Morning Music",
    volume: 60
}</pre>
    
    <h3>Output (Response Mode)</h3>
    <p>When "Wait for Response" is enabled:</p>
    <ul>
        <li><code>msg.payload</code> - Adapter response data</li>
        <li><code>msg.adapter</code> - Target adapter that was called</li>
        <li><code>msg.command</code> - Command that was sent</li>
        <li><code>msg.originalMessage</code> - Original message sent to adapter</li>
        <li><code>msg.responseTime</code> - Time taken for response (ms)</li>
        <li><code>msg.timestamp</code> - When response was received</li>
    </ul>
    
    <h3>Error Handling</h3>
    <ul>
        <li>Missing adapter specification triggers error</li>
        <li>Response timeouts generate error messages</li>
        <li>Invalid JSON in static message triggers validation error</li>
        <li>Connection issues are handled by underlying WebSocket manager</li>
    </ul>
    
    <h3>Adapter Compatibility</h3>
    <p>Works with any ioBroker adapter that supports sendTo messages:</p>
    <ul>
        <li><b>Notifications:</b> telegram, pushover, email, slack</li>
        <li><b>Databases:</b> sql, influxdb, history</li>
        <li><b>Media:</b> spotify, sonos, kodi</li>
        <li><b>Scripts:</b> javascript, node-red</li>
        <li><b>Services:</b> weather, calendar, backup</li>
    </ul>
    
    <h3>Performance Notes</h3>
    <ul>
        <li>Fire-and-forget mode is faster for simple notifications</li>
        <li>Response mode adds latency but provides feedback</li>
        <li>Timeout values should match expected adapter response times</li>
        <li>Avoid very short timeouts that may cause false failures</li>
    </ul>
</script>