<script type="text/javascript">
    RED.nodes.registerType('iobsendto', {
        category: 'ioBroker WS',
        color: '#a6bbcf',
        defaults: {
            name: { value: "" },
            adapter: { value: "" },
            command: { value: "" },
            message: { value: "" },
            waitForResponse: { value: false },
            responseTimeout: { value: 10000 },
            server: { value: "", type: "iob-config" }
        },
        inputs: 1,
        outputs: 1,
        icon: "iobroker_sendto.svg",
        paletteLabel: "WS ioB sendTo",
        label: function () {
            if (this.name) return this.name;

            let label = this.adapter || "iob-sendto";
            if (this.command) {
                label += ` (${this.command})`;
            }
            return label;
        },

        oneditprepare: function () {
            const node = this;
            const serverInput = $('#node-input-server');
            const adapterSelect = $('#node-input-adapter');
            const customAdapterInput = $('#node-input-custom-adapter');

            if (!this.server || this.server === '') {
                const configNodes = [];
                RED.nodes.eachConfig(function (config) {
                    if (config.type === 'iob-config') {
                        configNodes.push(config);
                    }
                });

                if (configNodes.length === 1) {
                    this.server = configNodes[0].id;
                    serverInput.val(this.server);

                    setTimeout(() => {
                        RED.notify(`Automatically selected server: ${configNodes[0].name || configNodes[0].iobhost}`, {
                            type: "info",
                            timeout: 1500
                        });
                    }, 500);
                }
            }

            initializeAdapterDropdown();

            adapterSelect.on('change', function () {
                const selectedValue = $(this).val();
                if (selectedValue === '__custom__') {
                    customAdapterInput.show().focus();
                    customAdapterInput.attr('required', true);
                } else {
                    customAdapterInput.hide();
                    customAdapterInput.attr('required', false);
                    customAdapterInput.val('');
                }
            });

            const currentAdapter = this.adapter;
            if (currentAdapter && currentAdapter.trim() !== '') {
                if (isCommonAdapter(currentAdapter)) {
                    adapterSelect.val(currentAdapter);
                    customAdapterInput.hide();
                } else {
                    adapterSelect.val('__custom__');
                    customAdapterInput.val(currentAdapter).show();
                    customAdapterInput.attr('required', true);
                }
            } else {
                adapterSelect.val('');
                customAdapterInput.hide();
            }

            $('#node-input-waitForResponse').on('change', function () {
                const isChecked = $(this).prop('checked');
                $('#response-timeout-container').toggle(isChecked);
                $('#response-info').toggle(isChecked);

                if (isChecked) {
                    $('#no-response-info').hide();
                } else {
                    $('#no-response-info').show();
                }
            });

            const waitForResponseChecked = $('#node-input-waitForResponse').prop('checked');
            $('#response-timeout-container').toggle(waitForResponseChecked);
            $('#response-info').toggle(waitForResponseChecked);
            $('#no-response-info').toggle(!waitForResponseChecked);

            function isCommonAdapter(adapterName) {
                const commonAdapters = [
                    '', 'telegram.0', 'email', 'pushover.0', 'javascript.0', 'sql.0',
                    'influxdb.0', 'spotify-premium.0', 'sonos.0', 'kodi.0', 'slack.0',
                    'whatsapp-cmb.0', 'signal.0', 'history.0'
                ];
                return commonAdapters.includes(adapterName);
            }

            function initializeAdapterDropdown() {
                adapterSelect.find('optgroup').remove();
                adapterSelect.find('option:contains("Loading")').remove();

                const customOption = adapterSelect.find('option[value="__custom__"]');
                $('<option value="" disabled>Loading adapters...</option>').insertAfter(customOption);

                setTimeout(() => {
                    loadAvailableAdapters();
                }, 1000);
            }

            function loadAvailableAdapters() {
                const serverNode = RED.nodes.node(serverInput.val());
                if (!serverNode) {
                    console.log('No server node selected for adapter discovery');
                    showFallbackAdapters();
                    return;
                }

                const serverId = `${serverNode.iobhost}:${serverNode.iobport}`;
                console.log('Loading adapters from:', serverId);

                $.ajax({
                    url: `/iobroker/ws/states/${encodeURIComponent(serverId)}`,
                    method: 'GET',
                    timeout: 15000,
                    dataType: 'json',
                    cache: false
                }).done(function (response) {
                    console.log('Adapter states response received');

                    if (response && typeof response === 'object') {
                        const adapters = extractAdaptersFromStates(response);

                        if (adapters.length > 0) {
                            populateAdapterDropdown(adapters);
                            console.log(`Found ${adapters.length} adapters on ${serverId}`);
                        } else {
                            showFallbackAdapters();
                        }
                    } else {
                        showFallbackAdapters();
                    }
                }).fail(function (xhr, status, error) {
                    console.error('Failed to load adapters:', status, error);
                    showFallbackAdapters();
                });
            }

            function extractAdaptersFromStates(states) {
                const adapterConfigs = new Map();

                Object.keys(states).forEach(stateId => {
                    const aliveMatch = stateId.match(/^system\.adapter\.([^.]+)\.(\d+)\.alive$/);
                    if (aliveMatch) {
                        const adapterType = aliveMatch[1];
                        const instance = parseInt(aliveMatch[2]);
                        const adapterName = `${adapterType}.${instance}`;

                        const state = states[stateId];
                        const isAlive = state && typeof state.val === 'boolean' ? state.val : Boolean(state?.val);

                        if (!adapterConfigs.has(adapterName)) {
                            adapterConfigs.set(adapterName, {
                                name: adapterName,
                                type: adapterType,
                                instance: instance,
                                enabled: false,
                                alive: isAlive
                            });
                        } else {
                            adapterConfigs.get(adapterName).alive = isAlive;
                        }
                    }

                    const enabledMatch = stateId.match(/^system\.adapter\.([^.]+)\.(\d+)\.enabled$/);
                    if (enabledMatch) {
                        const adapterType = enabledMatch[1];
                        const instance = parseInt(enabledMatch[2]);
                        const adapterName = `${adapterType}.${instance}`;

                        const state = states[stateId];
                        const isEnabled = state && typeof state.val === 'boolean' ? state.val : Boolean(state?.val);

                        if (!adapterConfigs.has(adapterName)) {
                            adapterConfigs.set(adapterName, {
                                name: adapterName,
                                type: adapterType,
                                instance: instance,
                                enabled: isEnabled,
                                alive: false
                            });
                        } else {
                            adapterConfigs.get(adapterName).enabled = isEnabled;
                        }
                    }
                });

                const adapters = [];
                for (const config of adapterConfigs.values()) {
                    if (!['admin', 'discovery', 'backitup', 'objects', 'states', 'web'].includes(config.type)) {
                        adapters.push(config);
                    }
                }

                adapters.sort((a, b) => {
                    if (a.type !== b.type) return a.type.localeCompare(b.type);
                    return a.instance - b.instance;
                });

                return adapters;
            }

            function populateAdapterDropdown(adapters) {
                adapterSelect.find('option:contains("Loading")').remove();
                adapterSelect.find('optgroup').remove();

                const runningAdapters = [];
                const enabledAdapters = [];
                const disabledAdapters = [];

                adapters.forEach(adapter => {
                    if (adapter.alive) {
                        runningAdapters.push(adapter);
                    } else if (adapter.enabled) {
                        enabledAdapters.push(adapter);
                    } else {
                        disabledAdapters.push(adapter);
                    }
                });

                const customOption = adapterSelect.find('option[value="__custom__"]');

                if (disabledAdapters.length > 0) {
                    const disabledGroup = $('<optgroup label="🔴 Disabled Adapters"></optgroup>');
                    disabledAdapters.forEach(adapter => {
                        disabledGroup.append(`<option value="${adapter.name}" style="color: #888;">${adapter.name}</option>`);
                    });
                    disabledGroup.insertAfter(customOption);
                }

                if (enabledAdapters.length > 0) {
                    const enabledGroup = $('<optgroup label="🟡 Enabled Adapters"></optgroup>');
                    enabledAdapters.forEach(adapter => {
                        enabledGroup.append(`<option value="${adapter.name}">${adapter.name}</option>`);
                    });
                    enabledGroup.insertAfter(customOption);
                }

                if (runningAdapters.length > 0) {
                    const runningGroup = $('<optgroup label="🟢 Running Adapters"></optgroup>');
                    runningAdapters.forEach(adapter => {
                        runningGroup.append(`<option value="${adapter.name}">${adapter.name}</option>`);
                    });
                    runningGroup.insertAfter(customOption);
                }

                const currentAdapter = node.adapter;
                if (currentAdapter && adapters.find(a => a.name === currentAdapter)) {
                    adapterSelect.val(currentAdapter);
                }
            }

            function showFallbackAdapters() {
                console.log('No adapters found or error occurred, showing fallback options');

                adapterSelect.find('option:contains("Loading")').remove();
                adapterSelect.find('optgroup').remove();

                const fallbackGroup = $('<optgroup label="⚠️ Common Adapters (not verified)"></optgroup>');
                const fallbackAdapters = [
                    'telegram.0', 'email', 'pushover.0', 'javascript.0', 'sql.0',
                    'influxdb.0', 'spotify-premium.0', 'sonos.0', 'kodi.0', 'slack.0'
                ];

                fallbackAdapters.forEach(adapter => {
                    fallbackGroup.append(`<option value="${adapter}" style="color: #666;">${adapter}</option>`);
                });

                const customOption = adapterSelect.find('option[value="__custom__"]');
                fallbackGroup.insertAfter(customOption);
            }

            serverInput.on('change', function () {
                console.log('Server changed, reloading adapters...');
                adapterSelect.find('optgroup').remove();
                adapterSelect.find('option:contains("Loading")').remove();

                setTimeout(() => {
                    initializeAdapterDropdown();
                }, 100);
            });
        },

        oneditsave: function () {
            const selectedAdapter = $('#node-input-adapter').val();
            const customAdapter = $('#node-input-custom-adapter').val().trim();

            console.log('Saving adapter config:', { selectedAdapter, customAdapter });

            if (selectedAdapter === '__custom__' && customAdapter) {
                this.adapter = customAdapter;
                console.log('Saved custom adapter:', customAdapter);
            } else if (selectedAdapter && selectedAdapter !== '__custom__') {
                this.adapter = selectedAdapter;
                console.log('Saved selected adapter:', selectedAdapter);
            } else {
                this.adapter = "";
                console.log('No adapter selected');
            }

            $('#node-input-custom-adapter').removeAttr('required');
        },

        oneditresize: function () {
        }
    });
</script>

<script type="text/html" data-template-name="iobsendto">
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Name">
    </div>
    
    <div class="form-row">
        <label for="node-input-adapter"><i class="icon-tag"></i> Target Adapter</label>
        <select id="node-input-adapter" style="width: 100%;">
            <option value="__custom__">✏️ Custom / Manual Input</option>
            <option value="">-- Select adapter or use msg.adapter --</option>
        </select>
        <input type="text" id="node-input-custom-adapter" placeholder="Enter custom adapter name (e.g. telegram.0)" 
               style="width: 100%; margin-top: 5px; display: none;">
        <div style="margin-top: 5px; font-size: 12px; color: #666;">
            If no adapter is selected, <code>msg.adapter</code> will be used
        </div>
    </div>
    
    <div class="form-row">
        <label for="node-input-command"><i class="icon-tag"></i> Command</label>
        <input type="text" id="node-input-command" placeholder="e.g. send, query, toScript (optional, can be empty)">
    </div>
    
    <div class="form-row">
        <label for="node-input-message"><i class="icon-tag"></i> Static Message</label>
        <textarea id="node-input-message" rows="4" style="width:100%; font-family: monospace;" placeholder="Optional JSON message (leave empty to use msg.payload)"></textarea>
        <div style="margin-top: 5px; font-size: 12px; color: #666;">
            If empty, <code>msg.payload</code> will be used as the message content
        </div>
    </div>
    
    <div class="form-row">
        <label for="node-input-waitForResponse" style="width: auto;">
            <input type="checkbox" id="node-input-waitForResponse" style="width: auto; margin-right: 5px;">
            <i class="icon-tag"></i> Wait for response
        </label>
    </div>
    
    <div class="form-row" id="response-timeout-container" style="display: none;">
        <label for="node-input-responseTimeout"><i class="icon-tag"></i> Response Timeout</label>
        <input type="number" id="node-input-responseTimeout" style="width: 120px;" min="1000" max="60000" step="1000"> ms
    </div>
    
    <div id="response-info" style="display: none; margin-top: 5px; padding: 8px; background-color: #e8f4fd; border: 1px solid #bee5eb; border-radius: 4px; font-size: 12px; color: #0c5460;">
        <i class="fa fa-info-circle"></i> <strong>Response Mode:</strong><br>
        Node will wait for adapter response and send it as output message. Useful for queries and commands that return data.
    </div>
    
    <div id="no-response-info" style="margin-top: 5px; padding: 8px; background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; font-size: 12px; color: #856404;">
        <i class="fa fa-info-circle"></i> <strong>Fire-and-forget Mode:</strong><br>
        Node will send the command and not wait for response. No output will be generated.
    </div>
    
    <div class="form-row">
        <label for="node-input-server"><i class="icon-tag"></i> Server</label>
        <input type="text" id="node-input-server">
    </div>
</script>

<script type="text/html" data-help-name="iobsendto">
    <p>Send commands and messages to ioBroker adapters via WebSocket using the sendTo functionality for service integration and automation.</p>
    
    <h3>Configuration</h3>
    <ul>
        <li><b>Target Adapter:</b> Select from dropdown or choose "Custom" for manual input. If empty, <code>msg.adapter</code> is used.</li>
        <li><b>Command:</b> Optional command parameter. Some adapters require this, others don't.</li>
        <li><b>Static Message:</b> Optional JSON message to send. If empty, <code>msg.payload</code> is used.</li>
        <li><b>Wait for Response:</b> Enable to receive adapter response as output message.</li>
        <li><b>Response Timeout:</b> Maximum time to wait for response (1-60 seconds).</li>
        <li><b>Server:</b> The ioBroker server configuration.</li>
    </ul>
    
    <h3>Adapter Selection</h3>
    <p>The dropdown shows available adapters grouped by status:</p>
    <ul>
        <li><b>🟢 Running Adapters:</b> Currently active and ready to receive commands</li>
        <li><b>🟡 Enabled Adapters:</b> Enabled but not currently running</li>
        <li><b>🔴 Disabled Adapters:</b> Available but disabled</li>
        <li><b>✏️ Custom:</b> Manually enter any adapter name</li>
    </ul>
    
    <h3>Input Message</h3>
    <p>Message properties that can override node configuration:</p>
    <ul>
        <li><code>msg.adapter</code> - Target adapter (overrides node setting)</li>
        <li><code>msg.command</code> - Command parameter (overrides node setting)</li>
        <li><code>msg.message</code> - Message content (overrides node setting and msg.payload)</li>
        <li><code>msg.payload</code> - Used as message if no static message configured</li>
        <li><code>msg.timeout</code> - Response timeout in milliseconds (overrides node setting)</li>
    </ul>
    
    <h3>Common Use Cases</h3>
    
    <h4>Telegram Notifications</h4>
    <pre>// Node config: adapter="telegram.0", command="send"
msg.payload = {
    text: "Motion detected in living room!",
    user: "admin"
}</pre>
    
    <h4>Email Alerts</h4>
    <pre>// Node config: adapter="email", command=""
msg.payload = {
    to: "admin@home.com",
    subject: "System Alert",
    text: "Temperature critical: 85°C"
}</pre>
    
    <h4>SQL Database Queries</h4>
    <pre>// Node config: adapter="sql.0", command="query", waitForResponse=true
msg.payload = "SELECT * FROM datapoints WHERE ts > NOW() - INTERVAL 1 DAY"</pre>
    
    <h4>JavaScript Execution</h4>
    <pre>// Node config: adapter="javascript.0", command="toScript"
msg.payload = {
    script: "myScript",
    message: { action: "cleanup", data: [1,2,3] }
}</pre>
    
    <h4>Media Control</h4>
    <pre>// Node config: adapter="spotify-premium.0", command="play"
msg.payload = {
    playlist: "Morning Music",
    volume: 60
}</pre>
    
    <h3>Output (Response Mode)</h3>
    <p>When "Wait for Response" is enabled:</p>
    <ul>
        <li><code>msg.payload</code> - Adapter response data</li>
        <li><code>msg.adapter</code> - Target adapter that was called</li>
        <li><code>msg.command</code> - Command that was sent</li>
        <li><code>msg.originalMessage</code> - Original message sent to adapter</li>
        <li><code>msg.responseTime</code> - Time taken for response (ms)</li>
        <li><code>msg.timestamp</code> - When response was received</li>
    </ul>
    
    <h3>Error Handling</h3>
    <ul>
        <li>Missing adapter specification triggers error</li>
        <li>Response timeouts generate error messages</li>
        <li>Invalid JSON in static message triggers validation error</li>
        <li>Connection issues are handled by underlying WebSocket manager</li>
    </ul>
    
    <h3>Adapter Compatibility</h3>
    <p>Works with any ioBroker adapter that supports sendTo messages:</p>
    <ul>
        <li><b>Notifications:</b> telegram, pushover, email, slack</li>
        <li><b>Databases:</b> sql, influxdb, history</li>
        <li><b>Media:</b> spotify, sonos, kodi</li>
        <li><b>Scripts:</b> javascript, node-red</li>
        <li><b>Services:</b> weather, calendar (not backitup - use states instead)</li>
    </ul>
    
    <h3>Performance Notes</h3>
    <ul>
        <li>Fire-and-forget mode is faster for simple notifications</li>
        <li>Response mode adds latency but provides feedback</li>
        <li>Timeout values should match expected adapter response times</li>
        <li>Avoid very short timeouts that may cause false failures</li>
    </ul>
</script>