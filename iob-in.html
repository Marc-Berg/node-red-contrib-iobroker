<!-- Complete iob-in.html with Automatic Wildcard Detection -->

<style>
.wildcard-disabled {
    opacity: 0.6;
}

.wildcard-disabled label {
    color: #999 !important;
}

.wildcard-disabled input[type="checkbox"]:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}
</style>

<script type="text/javascript">

// Hierarchical Search Tree (Complete TreeView Implementation)

(function() {
    if (typeof window.ioBrokerTreeView !== 'undefined') return;
    window.ioBrokerTreeView = true;
    
    const VIRTUAL_SCROLL_CONFIG = {
        ITEM_HEIGHT: 24,
        BUFFER_SIZE: 5,
        CHUNK_SIZE: 100,
        CACHE_DURATION: 5 * 60 * 1000
    };
    
    const stateCache = new Map();
    const performanceMetrics = {
        renderTime: 0,
        searchTime: 0,
        cacheHits: 0,
        cacheMisses: 0
    };
    
    if (!document.getElementById('iob-tree-styles')) {
        const style = document.createElement('style');
        style.id = 'iob-tree-styles';
        style.textContent = `
            .iob-virtual-container {
                height: 320px;
                overflow-y: auto;
                overflow-x: hidden;
                border: 1px solid #ccc;
                border-radius: 4px;
                background: #fafafa;
                display: none;
                position: relative;
            }
            
            .iob-tree-content {
                padding: 4px;
            }
            
            .iob-tree-item {
                height: ${VIRTUAL_SCROLL_CONFIG.ITEM_HEIGHT}px;
                display: flex;
                align-items: center;
                padding: 0 8px;
                cursor: pointer;
                white-space: nowrap;
                border-radius: 3px;
                transition: background-color 0.15s ease;
                user-select: none;
                font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
                font-size: 13px;
                line-height: 1.2;
                box-sizing: border-box;
                margin-bottom: 1px;
            }
            
            .iob-tree-item:hover { background-color: #e8f4f8; }
            .iob-tree-item.selected { background-color: #d4edda; border-left: 3px solid #28a745; }
            .iob-tree-item.folder { font-weight: 500; }
            .iob-tree-item.search-match { background-color: #fff3cd; border-left: 2px solid #ffc107; }
            .iob-tree-item.search-match:hover { background-color: #ffeaa7; }
            .iob-tree-item.search-path { background-color: #f8f9fa; border-left: 1px solid #dee2e6; }
            
            .iob-tree-icon {
                display: inline-flex; width: 18px; height: 18px; align-items: center;
                justify-content: center; margin-right: 6px; font-size: 12px; flex-shrink: 0;
            }
            
            .iob-tree-label { flex: 1; overflow: hidden; text-overflow: ellipsis; min-width: 0; }
            .iob-tree-label mark { background-color: #ffeb3b; padding: 1px 3px; border-radius: 2px; font-weight: bold; color: #333; }
            
            .iob-search-input {
                width: 100%; padding: 8px 12px; border: 1px solid #ddd; border-radius: 4px;
                font-size: 14px; box-sizing: border-box; margin-bottom: 8px;
            }
            .iob-search-input:focus { outline: none; border-color: #4CAF50; box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.2); }
            
            .iob-status { padding: 6px 10px; border-radius: 3px; font-size: 12px; font-weight: 500; margin-top: 5px; display: inline-block; }
            .iob-status-success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
            .iob-status-info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
            .iob-status-error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
            
            .iob-control-buttons { display: flex; gap: 8px; margin-top: 5px; }
            .iob-btn { padding: 6px 12px; border: 1px solid #ddd; border-radius: 4px; background: white; cursor: pointer; font-size: 12px; transition: all 0.2s ease; }
            .iob-btn:hover { background: #f8f9fa; border-color: #adb5bd; }
            .iob-btn.primary { background: #007bff; color: white; border-color: #007bff; }
            .iob-btn.primary:hover { background: #0056b3; border-color: #0056b3; }
            
            .iob-search-stats { font-size: 11px; color: #6c757d; margin-top: 4px; font-style: italic; }
            .iob-empty-state { padding: 40px 20px; text-align: center; color: #666; font-style: italic; background: #f8f9fa; border-radius: 4px; margin: 20px; }
        `;
        document.head.appendChild(style);
    }
    
    class HierarchicalTreeData {
        constructor() {
            this.allNodes = new Map();
            this.rootNodes = [];
            this.filteredNodes = [];
            this.searchIndex = new Map();
            this.currentSearchTerm = '';
            this.isSearchMode = false;
            this.searchMatches = new Set();
            this.searchPaths = new Set();
        }
        
        async buildFromStates(states) {
            console.time('TreeData.buildFromStates');
            
            this.clear();
            const stateIds = Object.keys(states);
            
            for (let i = 0; i < stateIds.length; i += VIRTUAL_SCROLL_CONFIG.CHUNK_SIZE) {
                const chunk = stateIds.slice(i, i + VIRTUAL_SCROLL_CONFIG.CHUNK_SIZE);
                await this.processChunk(chunk);
                
                const progress = Math.round((i / stateIds.length) * 100);
                this.updateProgress?.(progress);
                await new Promise(resolve => requestAnimationFrame(resolve));
            }
            
            this.buildNodeHierarchy();
            await this.buildSearchIndex();
            this.updateFilteredNodes();
            
            console.timeEnd('TreeData.buildFromStates');
            console.log(`Hierarchical tree built: ${this.allNodes.size} total nodes, search index: ${this.searchIndex.size} terms`);
        }
        
        async processChunk(stateIds) {
            stateIds.forEach(stateId => {
                const segments = stateId.split('.');
                let currentPath = '';
                
                for (let i = 0; i < segments.length; i++) {
                    const segment = segments[i];
                    const parentPath = currentPath;
                    currentPath = currentPath ? `${currentPath}.${segment}` : segment;
                    
                    if (!this.allNodes.has(currentPath)) {
                        const isLeaf = i === segments.length - 1;
                        const node = {
                            id: currentPath,
                            label: segment,
                            fullId: isLeaf ? stateId : null,
                            isLeaf: isLeaf,
                            depth: i,
                            parent: parentPath || null,
                            children: [],
                            expanded: false,
                            visible: true,
                            isMatch: false,
                            isPathToMatch: false
                        };
                        
                        this.allNodes.set(currentPath, node);
                    }
                }
            });
        }
        
        buildNodeHierarchy() {
            for (const [nodeId, node] of this.allNodes) {
                if (node.parent) {
                    const parentNode = this.allNodes.get(node.parent);
                    if (parentNode && !parentNode.children.includes(nodeId)) {
                        parentNode.children.push(nodeId);
                    }
                }
            }
            
            for (const [nodeId, node] of this.allNodes) {
                node.children.sort((a, b) => {
                    const nodeA = this.allNodes.get(a);
                    const nodeB = this.allNodes.get(b);
                    
                    if (nodeA.isLeaf !== nodeB.isLeaf) {
                        return nodeA.isLeaf ? 1 : -1;
                    }
                    return nodeA.label.localeCompare(nodeB.label, undefined, { numeric: true });
                });
            }
            
            this.rootNodes = Array.from(this.allNodes.values())
                .filter(node => !node.parent)
                .sort((a, b) => a.label.localeCompare(b.label, undefined, { numeric: true }))
                .map(node => node.id);
        }
        
        async buildSearchIndex() {
            console.time('buildSearchIndex');
            
            this.searchIndex.clear();
            
            for (const [nodeId, node] of this.allNodes) {
                const searchTerms = new Set();
                
                const label = node.label.toLowerCase();
                searchTerms.add(label);
                
                const fullNodeId = nodeId.toLowerCase();
                searchTerms.add(fullNodeId);
                
                const segments = nodeId.split('.');
                segments.forEach(segment => {
                    searchTerms.add(segment.toLowerCase());
                });
                
                for (let i = 1; i <= segments.length; i++) {
                    const partialPath = segments.slice(0, i).join('.').toLowerCase();
                    searchTerms.add(partialPath);
                }
                
                if (node.fullId && node.fullId !== nodeId) {
                    searchTerms.add(node.fullId.toLowerCase());
                }
                
                searchTerms.forEach(term => {
                    if (!this.searchIndex.has(term)) {
                        this.searchIndex.set(term, new Set());
                    }
                    this.searchIndex.get(term).add(nodeId);
                });
            }
            
            console.timeEnd('buildSearchIndex');
            console.log(`Search index built: ${this.searchIndex.size} terms for ${this.allNodes.size} nodes`);
        }
        
        performSearch(searchTerm) {
            console.time('HierarchicalSearch');
            
            this.currentSearchTerm = searchTerm.trim();
            this.isSearchMode = this.currentSearchTerm.length > 0;
            
            for (const node of this.allNodes.values()) {
                node.visible = true;
                node.isMatch = false;
                node.isPathToMatch = false;
                
                if (!this.isSearchMode) {
                    node.expanded = false;
                }
            }
            
            this.searchMatches.clear();
            this.searchPaths.clear();
            
            if (!this.isSearchMode) {
                this.updateFilteredNodes();
                console.timeEnd('HierarchicalSearch');
                return { results: [], total: this.filteredNodes.length };
            }
            
            const directMatches = this.findMatchingNodes(this.currentSearchTerm);
            
            directMatches.forEach(nodeId => {
                const node = this.allNodes.get(nodeId);
                if (node) {
                    node.isMatch = true;
                    this.searchMatches.add(nodeId);
                }
            });
            
            directMatches.forEach(nodeId => {
                this.markAncestorPathsAsVisible(nodeId);
            });
            
            this.filterNodesForSearch();
            this.autoExpandPathsToMatches();
            this.updateFilteredNodes();
            
            console.timeEnd('HierarchicalSearch');
            console.log(`Hierarchical search "${this.currentSearchTerm}" completed: ${directMatches.length} direct matches, ${this.searchPaths.size} path nodes`);
            
            return {
                results: directMatches,
                total: this.filteredNodes.length,
                searchTerm: this.currentSearchTerm
            };
        }
        
        findMatchingNodes(searchTerm) {
            const results = new Set();
            const lowerTerm = searchTerm.toLowerCase().trim();
            
            if (this.searchIndex.has(lowerTerm)) {
                const directMatches = this.searchIndex.get(lowerTerm);
                directMatches.forEach(nodeId => results.add(nodeId));
            }
            
            for (const [indexedTerm, nodeIds] of this.searchIndex) {
                if (indexedTerm.includes(lowerTerm) && indexedTerm !== lowerTerm) {
                    nodeIds.forEach(nodeId => results.add(nodeId));
                }
            }
            
            const searchWords = searchTerm.trim().split(/\s+/).filter(word => word.length > 0);
            if (searchWords.length > 1) {
                for (const [nodeId, node] of this.allNodes) {
                    const nodeText = nodeId.toLowerCase();
                    const labelText = node.label.toLowerCase();
                    const fullText = `${nodeText} ${labelText}`;
                    
                    if (searchWords.every(word => fullText.includes(word.toLowerCase()))) {
                        results.add(nodeId);
                    }
                }
            }
            
            return Array.from(results);
        }
        
        markAncestorPathsAsVisible(nodeId) {
            let currentNode = this.allNodes.get(nodeId);
            
            while (currentNode) {
                if (!currentNode.isMatch) {
                    currentNode.isPathToMatch = true;
                    this.searchPaths.add(currentNode.id);
                }
                
                if (currentNode.parent) {
                    currentNode = this.allNodes.get(currentNode.parent);
                } else {
                    break;
                }
            }
        }
        
        filterNodesForSearch() {
            for (const node of this.allNodes.values()) {
                node.visible = node.isMatch || node.isPathToMatch || this.hasMatchingDescendants(node.id);
            }
        }
        
        hasMatchingDescendants(nodeId) {
            const node = this.allNodes.get(nodeId);
            if (!node || node.isLeaf) return false;
            
            for (const childId of node.children) {
                const childNode = this.allNodes.get(childId);
                if (childNode && (childNode.isMatch || this.hasMatchingDescendants(childId))) {
                    return true;
                }
            }
            
            return false;
        }
        
        autoExpandPathsToMatches() {
            for (const pathNodeId of this.searchPaths) {
                const node = this.allNodes.get(pathNodeId);
                if (node && !node.isLeaf) {
                    node.expanded = true;
                }
            }
        }
        
        updateFilteredNodes() {
            this.filteredNodes = [];
            
            this.rootNodes.forEach(rootId => {
                this.addNodeToFilteredList(rootId);
            });
        }
        
        addNodeToFilteredList(nodeId) {
            const node = this.allNodes.get(nodeId);
            if (!node || !node.visible) return;
            
            this.filteredNodes.push({
                ...node,
                index: this.filteredNodes.length,
                isSearchMatch: node.isMatch,
                isSearchPath: node.isPathToMatch
            });
            
            if (node.expanded && node.children.length > 0) {
                node.children.forEach(childId => {
                    this.addNodeToFilteredList(childId);
                });
            }
        }
        
        toggleNodeExpansion(nodeId) {
            const node = this.allNodes.get(nodeId);
            if (node && !node.isLeaf) {
                node.expanded = !node.expanded;
                this.updateFilteredNodes();
                return true;
            }
            return false;
        }
        
        getFilteredNodes() {
            return this.filteredNodes;
        }
        
        clear() {
            this.allNodes.clear();
            this.rootNodes = [];
            this.filteredNodes = [];
            this.searchIndex.clear();
            this.currentSearchTerm = '';
            this.isSearchMode = false;
            this.searchMatches.clear();
            this.searchPaths.clear();
        }
    }
    
    class HierarchicalTreeView {
        constructor(container, data) {
            this.container = container;
            this.data = data;
            this.selectedNodeId = null;
            
            this.setupDOM();
            this.setupEventListeners();
        }
        
        setupDOM() {
            this.container.innerHTML = '<div class="iob-tree-content"></div>';
            this.content = this.container.querySelector('.iob-tree-content');
        }
        
        setupEventListeners() {
            this.content.addEventListener('click', (e) => {
                const item = e.target.closest('.iob-tree-item');
                if (item) this.handleItemClick(item);
            });
            
            this.content.addEventListener('dblclick', (e) => {
                const item = e.target.closest('.iob-tree-item');
                if (item) this.handleItemDoubleClick(item);
            });
        }
        
        render() {
            const nodes = this.data.getFilteredNodes();
            
            if (nodes.length === 0) {
                this.renderEmptyState();
                return;
            }
            
            const fragment = document.createDocumentFragment();
            
            nodes.forEach(node => {
                const element = this.createNodeElement(node);
                fragment.appendChild(element);
            });
            
            this.content.innerHTML = '';
            this.content.appendChild(fragment);
        }
        
        renderEmptyState() {
            const message = this.data.isSearchMode 
                ? `No states found containing "${this.data.currentSearchTerm}"`
                : 'No items to display';
                
            this.content.innerHTML = `<div class="iob-empty-state">${message}</div>`;
        }
        
        createNodeElement(node) {
            const element = document.createElement('div');
            element.className = `iob-tree-item ${node.isLeaf ? 'leaf' : 'folder'}`;
            element.dataset.nodeId = node.id;
            element.style.paddingLeft = `${(node.depth * 16) + 8}px`;
            
            if (node.isSearchMatch) {
                element.classList.add('search-match');
            } else if (node.isSearchPath) {
                element.classList.add('search-path');
            }
            
            if (node.id === this.selectedNodeId) {
                element.classList.add('selected');
            }
            
            const icon = node.isLeaf ? 'üîó' : (node.expanded ? 'üìÇ' : 'üìÅ');
            const label = this.highlightSearchTerm(node.label);
            
            element.innerHTML = `
                <span class="iob-tree-icon">${icon}</span>
                <span class="iob-tree-label" title="${node.id}">${label}</span>
            `;
            
            return element;
        }
        
        highlightSearchTerm(text) {
            if (!this.data.isSearchMode || !this.data.currentSearchTerm) {
                return text;
            }
            
            const searchTerm = this.data.currentSearchTerm.trim();
            const searchWords = searchTerm.split(/\s+/).filter(word => word.length > 0);
            let result = text;
            
            searchWords.forEach(word => {
                const regex = new RegExp(`(${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                result = result.replace(regex, '<mark>$1</mark>');
            });
            
            if (searchWords.length > 1) {
                const completeTermRegex = new RegExp(`(${searchTerm.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')})`, 'gi');
                result = result.replace(completeTermRegex, '<mark>$1</mark>');
            }
            
            return result;
        }
        
        handleItemClick(element) {
            const nodeId = element.dataset.nodeId;
            
            this.container.querySelectorAll('.iob-tree-item.selected').forEach(el => {
                el.classList.remove('selected');
            });
            element.classList.add('selected');
            this.selectedNodeId = nodeId;
            
            if (this.data.toggleNodeExpansion(nodeId)) {
                this.render();
            }
        }
        
        handleItemDoubleClick(element) {
            const nodeId = element.dataset.nodeId;
            const node = this.data.allNodes.get(nodeId);
            
            if (node && node.isLeaf && node.fullId) {
                this.onStateSelected?.(node.fullId);
            }
        }
        
        updateSearch(searchTerm) {
            const searchResults = this.data.performSearch(searchTerm);
            this.render();
            return searchResults;
        }
        
        destroy() {
            this.container.innerHTML = '';
        }
    }
    
    function getCacheKey(serverHost, serverPort) {
        return `${serverHost}:${serverPort}`;
    }
    
    function isCacheValid(cacheEntry) {
        if (!cacheEntry) return false;
        return (Date.now() - cacheEntry.timestamp) < VIRTUAL_SCROLL_CONFIG.CACHE_DURATION;
    }
    
    function getCachedStates(serverId) {
        const cacheEntry = stateCache.get(serverId);
        if (isCacheValid(cacheEntry)) {
            performanceMetrics.cacheHits++;
            return cacheEntry.data;
        }
        performanceMetrics.cacheMisses++;
        return null;
    }
    
    function setCachedStates(serverId, data) {
        stateCache.set(serverId, {
            data: data,
            timestamp: Date.now()
        });
    }
    
    window.ioBrokerTreeView = {
        setup: function(nodeType, stateInputId, serverInputId) {
            const stateInput = $('#' + stateInputId);
            const serverInput = $('#' + serverInputId);
            
            const treeContainer = $('<div class="iob-virtual-container"></div>');
            const searchContainer = $(`
                <div class="iob-search-container" style="display:none;">
                    <input type="text" class="iob-search-input" placeholder="Search states (hierarchical filtering)...">
                </div>
            `);
            const controlButtons = $(`
                <div class="iob-control-buttons">
                    <button type="button" class="iob-btn primary">Switch to tree selection</button>
                    <button type="button" class="iob-btn" title="Refresh states">
                        <i class="fa fa-refresh"></i> Refresh
                    </button>
                    <button type="button" class="iob-btn" title="Clear search">
                        <i class="fa fa-times"></i> Clear
                    </button>
                </div>
            `);
            const statusElement = $('<div class="iob-status"></div>');
            const searchStatsElement = $('<div class="iob-search-stats"></div>');
            
            stateInput.after(searchStatsElement).after(statusElement).after(treeContainer).after(searchContainer).after(controlButtons);
            
            const toggleButton = controlButtons.find('.iob-btn.primary');
            const refreshButton = controlButtons.find('.iob-btn:not(.primary)').first();
            const clearButton = controlButtons.find('.iob-btn:not(.primary)').last();
            const searchInput = searchContainer.find('.iob-search-input');
            
            const treeData = new HierarchicalTreeData();
            let treeView = null;
            let currentServerId = null;
            let statesLoaded = false;
            let searchTimeout = null;
            
            treeData.updateProgress = (progress) => {
                if (progress >= 100) {
                    showStatus('success', 'Hierarchical tree processing complete');
                }
            };
            
            async function loadTree(forceRefresh = false) {
                console.time('Hierarchical Tree Loading');
                
                const serverNode = RED.nodes.node(serverInput.val());
                if (!serverNode) {
                    showError('No server selected');
                    return;
                }
                
                const serverId = getCacheKey(serverNode.iobhost, serverNode.iobport);
                currentServerId = serverId;
                
                if (!forceRefresh) {
                    const cachedData = getCachedStates(serverId);
                    if (cachedData) {
                        await renderTree(cachedData, true);
                        console.timeEnd('Hierarchical Tree Loading');
                        return;
                    }
                }
                
                try {
                    showStatus('info', 'Loading states from ioBroker...');
                    treeContainer.html('<div style="padding: 20px; text-align: center;"><i class="fa fa-spinner fa-spin"></i> Loading hierarchical tree view...</div>');
                    
                    const response = await $.ajax({
                        url: `/iobroker/ws/states/${encodeURIComponent(serverId)}`,
                        method: 'GET',
                        timeout: 20000,
                        dataType: 'json'
                    });
                    
                    const stateCount = Object.keys(response).length;
                    if (stateCount === 0) throw new Error('No states received');
                    
                    setCachedStates(serverId, response);
                    await renderTree(response, false);
                    
                } catch (error) {
                    console.error('Hierarchical tree loading failed:', error);
                    showError(`Error: ${error.message || 'Unknown error'}`);
                } finally {
                    console.timeEnd('Hierarchical Tree Loading');
                }
            }
            
            async function renderTree(statesData, fromCache) {
                console.time('Hierarchical Tree Rendering');
                
                await treeData.buildFromStates(statesData);
                
                if (treeView) {
                    treeView.destroy();
                }
                
                treeView = new HierarchicalTreeView(treeContainer[0], treeData);
                treeView.onStateSelected = (stateId) => {
                    stateInput.val(stateId).trigger('change');
                    RED.notify(`Selected: ${stateId}`, { type: "success", timeout: 2000 });
                    setTimeout(() => toggleInputMode(), 300);
                };
                
                treeView.render();
                
                statesLoaded = true;
                const stateCount = Object.keys(statesData).length;
                const cacheStatus = fromCache ? '(cached)' : '(fresh)';
                
                showStatus('success', `Loaded ${stateCount} states ${cacheStatus} - Hierarchical search ready`);
                
                console.timeEnd('Hierarchical Tree Rendering');
            }
            
            searchInput.on('input', function() {
                clearTimeout(searchTimeout);
                const searchTerm = $(this).val().trim();
                
                searchTimeout = setTimeout(() => {
                    if (treeView && treeData) {
                        const searchStats = treeView.updateSearch(searchTerm);
                        
                        if (searchTerm) {
                            const stateText = searchStats.results.length === 1 ? 'state' : 'states';
                            searchStatsElement.html(
                                `Found ${searchStats.results.length} matching ${stateText} for "${searchStats.searchTerm}"`
                            ).show();
                        } else {
                            searchStatsElement.html('Showing complete tree structure').show();
                            setTimeout(() => searchStatsElement.hide(), 2000);
                        }
                    }
                }, 200);
            });
            
            function toggleInputMode() {
                const isManualVisible = stateInput.is(':visible');
                stateInput.toggle(!isManualVisible);
                treeContainer.toggle(isManualVisible);
                searchContainer.toggle(isManualVisible);
                
                if (!isManualVisible) {
                    statusElement.hide();
                    searchStatsElement.hide();
                }
                
                toggleButton.text(isManualVisible ? 'Switch to manual input' : 'Switch to hierarchical tree');
                
                if (isManualVisible && !statesLoaded) {
                    loadTree();
                }
            }
            
            function showStatus(type, message) {
                const iconMap = {
                    success: 'fa-check-circle',
                    info: 'fa-info-circle',
                    error: 'fa-exclamation-triangle'
                };
                
                statusElement.html(`
                    <span class="iob-status iob-status-${type}">
                        <i class="fa ${iconMap[type]}"></i> ${message}
                    </span>
                `).show();
            }
            
            function showError(message) {
                showStatus('error', message);
                treeContainer.html(`
                    <div style="padding: 20px; text-align: center; color: #dc3545;">
                        <i class="fa fa-exclamation-triangle"></i> ${message}
                        <br><small>Check server connection and try refreshing</small>
                    </div>
                `);
            }
            
            toggleButton.on('click', toggleInputMode);
            
            refreshButton.on('click', function() {
                if (currentServerId) {
                    stateCache.delete(currentServerId);
                    const icon = $(this).find('i');
                    icon.addClass('fa-spin');
                    
                    loadTree(true).finally(() => {
                        setTimeout(() => icon.removeClass('fa-spin'), 500);
                    });
                    
                    RED.notify('Refreshing hierarchical tree view...', { type: "info", timeout: 2000 });
                }
            });
            
            clearButton.on('click', function() {
                searchInput.val('').trigger('input');
                searchInput.focus();
            });
            
            serverInput.on('change', function() {
                treeData.clear();
                if (treeView) {
                    treeView.destroy();
                    treeView = null;
                }
                statesLoaded = false;
                statusElement.html('');
                searchStatsElement.hide();
                
                if (treeContainer.is(':visible')) {
                    loadTree();
                }
            });
            
            return {
                cleanup: function() {
                    if (treeView) treeView.destroy();
                    clearTimeout(searchTimeout);
                    controlButtons.remove();
                    searchContainer.remove();
                    treeContainer.remove();
                    statusElement.remove();
                    searchStatsElement.remove();
                    stateInput.show();
                }
            };
        }
    };
})();

// Enhanced Node Registration with Automatic Wildcard Detection
RED.nodes.registerType('iobin', {
    category: 'ioBroker',
    color: '#a6bbcf',
    defaults: {
        name: { value: "" },
        state: { value: "", required: true },
        outputProperty: { value: "payload" },
        ackFilter: { value: "both" },
        sendInitialValue: { value: false },
        useWildcard: { value: false }, // This will be auto-set based on pattern detection
        outputMode: { value: "individual" },
        server: { value: "", type: "iob-config" }
    },
    inputs: 0,
    outputs: 1,
    icon: "iobroker_in.svg",
    paletteLabel: "WS ioB in",
    label: function() {
        if (this.name) return this.name;
        
        if (this.state && this.state.includes('*')) {
            return `${this.state} (wildcard)`;
        }
        
        return this.state || "iob-in";
    },
    oneditprepare: function() {
        const node = this;
        
        // Auto-select server configuration
        const serverInput = $('#node-input-server');
        
        if (!this.server || this.server === '') {
            const configNodes = [];
            RED.nodes.eachConfig(function(config) {
                if (config.type === 'iob-config') {
                    configNodes.push(config);
                }
            });
            
            if (configNodes.length === 1) {
                this.server = configNodes[0].id;
                serverInput.val(this.server);
                
                setTimeout(() => {
                    RED.notify(`Auto-selected server: ${configNodes[0].name || configNodes[0].iobhost}`, {
                        type: "info",
                        timeout: 1500
                    });
                }, 500);
            }
        }
        
        // Automatic wildcard pattern detection and UI updates
        function updateWildcardMode() {
            const stateValue = $('#node-input-state').val();
            const hasWildcardChars = stateValue.includes('*'); // Only * is supported by ioBroker
            const hasUnsupportedChars = stateValue.includes('?');
            
            // Automatic wildcard mode detection based on pattern content
            const wildcardModeActive = hasWildcardChars;
            
            // Show/hide wildcard-specific options based on pattern content
            if (wildcardModeActive) {
                $('#wildcard-info').show();
                updateStateInputPlaceholder(true);
                
                // Disable initial value option for wildcards
                $('#node-input-sendInitialValue').prop('checked', false).prop('disabled', true);
                $('#initial-value-container').addClass('wildcard-disabled');
                showInitialValueWarning();
                
                // Show wildcard info when * is detected
                showWildcardInfo();
            } else {
                $('#wildcard-info').hide();
                updateStateInputPlaceholder(false);
                
                // Re-enable initial value option for single states
                $('#node-input-sendInitialValue').prop('disabled', false);
                $('#initial-value-container').removeClass('wildcard-disabled');
                hideInitialValueWarning();
            }
            
            // Validate pattern (show warnings for unsupported ? wildcards)
            if (stateValue && (wildcardModeActive || hasUnsupportedChars)) {
                validateWildcardPattern(stateValue);
            } else {
                $('#wildcard-validation').hide();
            }
        }
        
        function updateStateInputPlaceholder(isWildcard) {
            const stateInput = $('#node-input-state');
            if (isWildcard) {
                stateInput.attr('placeholder', 'e.g. 0_userdata.0.*, system.adapter.*.alive (only * supported)');
            } else {
                stateInput.attr('placeholder', 'e.g. 0_userdata.0.test');
            }
        }
        
        function validateWildcardPattern(pattern) {
            const validationDiv = $('#wildcard-validation');
            
            if (!pattern) {
                validationDiv.hide();
                return;
            }
            
            // Basic validation rules for ioBroker wildcards
            const issues = [];
            
            // Check for unsupported wildcard characters
            if (pattern.includes('?')) {
                issues.push('ioBroker only supports * wildcards, not ? wildcards');
            }
            
            // Check for invalid wildcard usage
            if (pattern.includes('**')) {
                issues.push('Avoid consecutive wildcards (**)');
            }
            
            if (pattern.startsWith('*')) {
                issues.push('Patterns starting with * may match too many states');
            }
            
            if (pattern.split('*').length > 4) {
                issues.push('Too many wildcards may impact performance');
            }
            
            // Check for potentially problematic patterns
            if (pattern === '*' || pattern === '*.*') {
                issues.push('This pattern will match ALL states - use with caution!');
            }
            
            if (issues.length > 0) {
                validationDiv.html(`
                    <div style="color: #f39c12; font-size: 12px; margin-top: 5px;">
                        <i class="fa fa-exclamation-triangle"></i> 
                        ${issues.join('; ')}
                    </div>
                `).show();
            } else if (pattern.includes('*')) {
                validationDiv.html(`
                    <div style="color: #28a745; font-size: 12px; margin-top: 5px;">
                        <i class="fa fa-check"></i> 
                        Wildcard pattern looks good
                    </div>
                `).show();
            } else {
                validationDiv.hide();
            }
        }
        
        function showWildcardInfo() {
            $('#wildcard-info').html(`
                <div style="background-color: #e8f4fd; border: 1px solid #bee5eb; border-radius: 4px; padding: 10px; font-size: 13px; color: #0c5460;">
                    <i class="fa fa-info-circle" style="color: #17a2b8; margin-right: 5px;"></i>
                    <strong>Wildcard Mode (Auto-detected):</strong><br>
                    <ul style="margin: 8px 0 0 20px; padding: 0;">
                        <li><code>*</code> matches any number of characters</li>
                        <li><code>?</code> is <strong>not supported</strong> by ioBroker</li>
                        <li>Example: <code>system.adapter.*.alive</code></li>
                        <li><strong>Note:</strong> Initial values are disabled for wildcards</li>
                    </ul>
                </div>
            `).show();
        }
        
        function showInitialValueWarning() {
            $('#initial-value-warning').html(`
                <div style="background-color: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 8px; font-size: 12px; color: #856404; margin-top: 5px;">
                    <i class="fa fa-exclamation-triangle" style="color: #f39c12; margin-right: 5px;"></i>
                    Initial values are disabled for wildcard patterns to prevent performance issues.
                </div>
            `).show();
        }
        
        function hideInitialValueWarning() {
            $('#initial-value-warning').hide();
        }
        
        // Event handlers - FIXED: Added 'change' event for treeview selections
        $('#node-input-state').on('input keyup change', function() {
            updateWildcardMode();
        });
        
        // Initial setup
        updateWildcardMode();
        
        // Initialize tree view
        this.treeController = window.ioBrokerTreeView.setup('iobin', 'node-input-state', 'node-input-server');
    },
    oneditsave: function() {
        // Auto-detect and save wildcard mode based on pattern (only * is supported by ioBroker)
        const stateValue = $('#node-input-state').val();
        const hasWildcardChars = stateValue.includes('*'); // Only * is supported
        
        // Automatically set useWildcard based on pattern detection
        this.useWildcard = hasWildcardChars;
        
        if (hasWildcardChars) {
            // Force disable initial values for wildcards
            this.sendInitialValue = false;
        }
        
        // Cleanup tree controller
        if (this.treeController) {
            this.treeController.cleanup();
        }
    },
    oneditresize: function() {
        // Handle responsive design - placeholder for future enhancements
    }
});
</script>

<script type="text/html" data-template-name="iobin">
    <div class="form-row">
        <label for="node-input-name"><i class="icon-tag"></i> Name</label>
        <input type="text" id="node-input-name" placeholder="Node name (optional)">
    </div>
    
    <div class="form-row">
        <label for="node-input-state"><i class="icon-tag"></i> State ID / Pattern</label>
        <input type="text" id="node-input-state" placeholder="e.g. 0_userdata.0.test" required>
        <div id="wildcard-validation" style="display: none;"></div>
    </div>
    
    <!-- Wildcard Information (Auto-shown when * is detected) -->
    <div id="wildcard-info" style="display: none; margin-bottom: 15px;"></div>
      
    <div class="form-row">
        <label for="node-input-outputProperty"><i class="icon-tag"></i> Output Property</label>
        <input type="text" id="node-input-outputProperty" placeholder="payload">
    </div>
    
    <div class="form-row">
        <label for="node-input-ackFilter"><i class="icon-tag"></i> Trigger on</label>
        <select id="node-input-ackFilter" style="width:100%">
            <option value="both">Both (ack and no-ack)</option>
            <option value="ack">Acknowledged only (ack=true)</option>
            <option value="noack">Unacknowledged only (ack=false)</option>
        </select>
    </div>
    
    <div class="form-row" id="initial-value-container">
        <label for="node-input-sendInitialValue" style="width: auto;">
            <input type="checkbox" id="node-input-sendInitialValue" style="width: auto; margin-right: 5px;">
            <i class="icon-tag"></i> Send initial value on startup
        </label>
        <div id="initial-value-warning" style="display: none;"></div>
    </div>
    
    <div class="form-row">
        <label for="node-input-server"><i class="icon-tag"></i> Server</label>
        <input type="text" id="node-input-server" required>
    </div>
</script>

<script type="text/html" data-help-name="iobin">
    <p>ioBroker state subscription via WebSocket with automatic Wildcard detection.</p>
    
    <h3>Input Modes</h3>
    <ul>
        <li><b>Single State:</b> Subscribe to one specific state ID</li>
        <li><b>Wildcard Pattern:</b> Subscribe to multiple states matching a pattern (auto-detected when * is present)</li>
    </ul>
    
    <h3>Wildcard Patterns</h3>
    <ul>
        <li><code>*</code> matches any number of characters</li>
        <li><code>?</code> is <strong>not supported</strong> by ioBroker</li>
        <li>Examples:
            <ul>
                <li><code>system.adapter.*.alive</code> - all adapter alive states</li>
                <li><code>0_userdata.0.*</code> - all states under 0_userdata.0</li>
                <li><code>*.temperature</code> - all temperature states</li>
            </ul>
        </li>
        <li><strong>Note:</strong> Wildcard mode is automatically detected when * is present in the pattern</li>
    </ul>
    
    <h3>State Selection</h3>
    <ul>
        <li><b>Manual input:</b> Type the state ID or pattern directly</li>
        <li><b>Tree browser:</b> Browse and select from available states</li>
        <li><b>Auto-detection:</b> Wildcard mode is enabled automatically when * is detected in the pattern</li>
    </ul>
    
    <h3>Configuration</h3>
    <ul>
        <li><b>Trigger on:</b> Filter by acknowledgment status</li>
        <li><b>Send initial values:</b> Emit current value immediately after connection (single states only)</li>
    </ul>
    
    <h3>Output</h3>
    <ul>
        <li>State value in <code>msg.[outputProperty]</code> when it changes</li>
        <li>Complete state object in <code>msg.state</code></li>
        <li>State ID in <code>msg.topic</code></li>
        <li>Timestamp in <code>msg.timestamp</code></li>
        <li><b>For wildcards:</b> Original pattern in <code>msg.pattern</code></li>
    </ul>
    
    <h3>Performance Notes</h3>
    <ul>
        <li>Avoid overly broad patterns like <code>*</code> or <code>*.*</code></li>
        <li><b>Initial values are disabled for wildcards</b> to prevent performance issues</li>
    </ul>
</script>